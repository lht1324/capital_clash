'use client'

import { Canvas, useThree, useFrame } from '@react-three/fiber'
import { useRef, useState, useCallback, useEffect, useMemo } from 'react'
import * as THREE from 'three'
import { useContinentStore, type Continent } from '@/store/continentStore'
import { spiralPlacement } from '@/utils/spiralPlacement'
import { spiralPlacement } from '@/utils/spiralPlacement'

function CameraController() {
  const { camera, gl } = useThree()
  const { selectedContinent, continents, isWorldView, setSelectedContinent, setWorldView, cameraTarget, setCameraTarget } = useContinentStore()
  
  const [isDragging, setIsDragging] = useState(false)
  const previousMouse = useRef({ x: 0, y: 0 })
  const cameraPosition = useRef(new THREE.Vector3(0, 0, 60)) // 30 → 60 (2배)
  const targetPosition = useRef(new THREE.Vector3(0, 0, 60)) // 30 → 60 (2배)
  
  // 드롭다운 선택에 따른 카메라 이동 처리
  useEffect(() => {
    if (cameraTarget) {
      const [x, y, z] = cameraTarget
      console.log('드롭다운 선택으로 카메라 이동:', x, y, z)
      targetPosition.current.set(x, y, z)
      setCameraTarget(null) // 이동 완료 후 타겟 초기화
    }
  }, [cameraTarget, setCameraTarget])
  
  // 현재 위치 기반 드롭다운 반영 함수 (포커싱 없음)
  const updateDropdownBasedOnPosition = useCallback(() => {
    if (isDragging) return // 드래그 중에는 업데이트 안함

    const currentPos = camera.position
    let nearestContinent: string | null = null
    let minDistance = Infinity
    
    Object.values(continents).forEach((continent) => {
      const [x, y, z] = continent.position
      const distance = Math.sqrt(
        Math.pow(currentPos.x - x, 2) + 
        Math.pow(currentPos.y - y, 2)
      )
      
      if (distance < minDistance && distance < 30) { // 30 단위 내에서만 감지 (15→30)
        minDistance = distance
        nearestContinent = continent.id
      }
    })
    
    // 드롭다운만 변경, 카메라 이동 없음
    if (nearestContinent && nearestContinent !== selectedContinent) {
      const continent = continents[nearestContinent as keyof typeof continents]
      console.log('위치 기반 드롭다운 변경:', continent.name)
      setSelectedContinent(nearestContinent as any)
      setWorldView(false)
    } else if (!nearestContinent && !isWorldView) {
      console.log('세계 지도로 드롭다운 변경')
      setWorldView(true)
    }
  }, [camera, continents, selectedContinent, isWorldView, isDragging, setSelectedContinent, setWorldView])
  
  // Canvas 마우스 이벤트 설정 - 전역 이벤트로 수정
  useEffect(() => {
    const canvas = gl.domElement
    
    const handlePointerDown = (event: PointerEvent) => {
      setIsDragging(true)
      previousMouse.current = { x: event.clientX, y: event.clientY }
      canvas.style.cursor = 'grabbing'
      event.preventDefault()
    }
    
    // 전역에서 pointermove와 pointerup 처리 (드래그 상태 유지)
    const handlePointerMove = (event: PointerEvent) => {
      if (!isDragging) return
      
      const deltaX = event.clientX - previousMouse.current.x
      const deltaY = event.clientY - previousMouse.current.y
      
      // 이동 방향을 마우스와 반대로 - 지도를 잡아당기는 느낌 (속도 1.5배 증가)
      const sensitivity = 0.015 // 0.01 -> 0.015로 1.5배 증가
      targetPosition.current.x -= deltaX * sensitivity  // 마우스 반대 방향
      targetPosition.current.y += deltaY * sensitivity  // 마우스 반대 방향
      
      previousMouse.current = { x: event.clientX, y: event.clientY }
      event.preventDefault()
    }
    
    const handlePointerUp = (event: PointerEvent) => {
      if (isDragging) {
        setIsDragging(false)
        canvas.style.cursor = 'grab'
        event.preventDefault()
      }
    }
    
    const handleWheel = (event: WheelEvent) => {
      event.preventDefault()
      // 줌 속도 증가 (0.002 -> 0.008로 4배 증가)
      const zoomSpeed = 0.008
      targetPosition.current.z += event.deltaY * zoomSpeed
      targetPosition.current.z = Math.max(15, Math.min(120, targetPosition.current.z)) // 5-50 → 15-120
    }
    
    // Canvas에는 pointerdown과 wheel만
    canvas.addEventListener('pointerdown', handlePointerDown)
    canvas.addEventListener('wheel', handleWheel)
    
    // 전역에는 pointermove와 pointerup (드래그 상태 유지)
    document.addEventListener('pointermove', handlePointerMove)
    document.addEventListener('pointerup', handlePointerUp)
    
    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown)
      canvas.removeEventListener('wheel', handleWheel)
      document.removeEventListener('pointermove', handlePointerMove)
      document.removeEventListener('pointerup', handlePointerUp)
    }
  }, [gl, isDragging])
  
  useFrame(() => {
    // 부드러운 카메라 이동 - 속도 증가
    cameraPosition.current.lerp(targetPosition.current, 0.12) // 0.08 -> 0.12로 속도 증가
    camera.position.copy(cameraPosition.current)
    
    // 현재 위치 기반 드롭다운 업데이트 (포커싱 없음)
    updateDropdownBasedOnPosition()
  })
  
  return null
}

// 50x50 격자 기반 정사각형 배치 시스템
const GRID_SIZE = 50 // 50x50 격자
const TOTAL_CELLS = GRID_SIZE * GRID_SIZE // 2500개 셀

// 지분을 격자 개수로 변환
const shareToGridCount = (share: number): number => {
  return Math.round(share * TOTAL_CELLS)
}

// 격자 개수를 가장 가까운 제곱수로 변환 (50x50 정밀 버전)
const gridCountToSquareSize = (gridCount: number): number => {
  // 목표 격자 개수보다 작은 제곱수들을 모두 생성
  const perfectSquares = []
  for (let i = 1; i * i < gridCount && i * i <= TOTAL_CELLS; i++) {
    perfectSquares.push(i * i)
  }
  
  // 빈 배열이면 최소 크기 1×1 반환
  if (perfectSquares.length === 0) {
    return 1
  }
  
  // 목표 격자 개수와 가장 가까운 제곱수 찾기
  let bestSquare = perfectSquares[0]
  let minDifference = Math.abs(gridCount - bestSquare)
  
  for (const square of perfectSquares) {
    const difference = Math.abs(gridCount - square)
    if (difference < minDifference) {
      minDifference = difference
      bestSquare = square
    }
  }
  
  return Math.sqrt(bestSquare) // 한 변의 길이 반환
}



// "소용돌이 배치" 알고리즘
const spiralPlacement = (investors: any[]) => {
  console.log(`🌀 소용돌이 배치 시작: ${investors.length}명`)
  
  if (investors.length === 0) return []
  
  // 1. 투자자들을 지분 크기 순으로 정렬 (큰 것부터)
  const sortedInvestors = [...investors].sort((a, b) => b.share - a.share)
  console.log('📊 크기 순 정렬:', sortedInvestors.map(inv => `${inv.name}: ${inv.share.toFixed(1)}%`))
  
  // 2. 각 투자자의 크기 계산 (지분에 따른 정사각형 크기)
  const investorSizes = sortedInvestors.map(investor => {
    const targetCells = Math.round(investor.share_percentage * TOTAL_CELLS)
    const side = Math.max(1, Math.floor(Math.sqrt(targetCells)))
    return {
      investor,
      size: side,
      targetCells
    }
  })
  
  // 3. 50x50 격자에 소용돌이 배치
  const occupied = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false))
  const placedSquares: any[] = []
  const centerX = Math.floor(GRID_SIZE / 2)
  const centerY = Math.floor(GRID_SIZE / 2)
  
  console.log(`🎯 중심점: (${centerX}, ${centerY})`)
  
  for (let i = 0; i < investorSizes.length; i++) {
    const { investor, size } = investorSizes[i]
    let placed = false
    
    if (i === 0) {
      // 가장 큰 투자자를 중심에 배치
      const startX = centerX - Math.floor(size / 2)
      const startY = centerY - Math.floor(size / 2)
      
      if (canPlaceAt(occupied, startX, startY, size)) {
        placeAt(occupied, startX, startY, size)
        placedSquares.push({
          investor,
          gridX: startX,
          gridY: startY,
          gridSize: size
        })
        console.log(`🎯 중심 배치: ${investor.name} ${size}×${size} → (${startX}, ${startY})`)
        placed = true
      }
    } else {
      // 나머지는 소용돌이 패턴으로 배치
      const spiralPositions = generateSpiralPositions(centerX, centerY, GRID_SIZE)
      
      for (const pos of spiralPositions) {
        const startX = pos.x - Math.floor(size / 2)
        const startY = pos.y - Math.floor(size / 2)
        
        if (canPlaceAt(occupied, startX, startY, size)) {
          placeAt(occupied, startX, startY, size)
          placedSquares.push({
            investor,
            gridX: startX,
            gridY: startY,
            gridSize: size
          })
          console.log(`🌀 소용돌이 배치: ${investor.name} ${size}×${size} → (${startX}, ${startY})`)
          placed = true
          break
        }
      }
    }
    
    if (!placed) {
      console.log(`❌ 배치 실패: ${investor.name}, 1×1로 축소 시도`)
      // 배치 실패시 1×1로 축소해서 재시도
      const spiralPositions = generateSpiralPositions(centerX, centerY, GRID_SIZE)
      for (const pos of spiralPositions) {
        if (canPlaceAt(occupied, pos.x, pos.y, 1)) {
          placeAt(occupied, pos.x, pos.y, 1)
          placedSquares.push({
            investor,
            gridX: pos.x,
            gridY: pos.y,
            gridSize: 1
          })
          console.log(`🔧 1×1 배치: ${investor.name} → (${pos.x}, ${pos.y})`)
          break
        }
      }
    }
  }
  
  console.log(`🌀 소용돌이 배치 완료: ${placedSquares.length}개`)
  return placedSquares
}

// 배치 가능 여부 확인
function canPlaceAt(occupied: boolean[][], startX: number, startY: number, size: number): boolean {
  if (startX < 0 || startY < 0 || startX + size > GRID_SIZE || startY + size > GRID_SIZE) {
    return false
  }
  
  for (let y = startY; y < startY + size; y++) {
    for (let x = startX; x < startX + size; x++) {
      if (occupied[y][x]) {
        return false
      }
    }
  }
  return true
}

// 격자에 배치하기
function placeAt(occupied: boolean[][], startX: number, startY: number, size: number): void {
  for (let y = startY; y < startY + size; y++) {
    for (let x = startX; x < startX + size; x++) {
      occupied[y][x] = true
    }
  }
}

// 소용돌이 패턴 좌표 생성 (중심에서 시작해서 시계방향으로)
function generateSpiralPositions(centerX: number, centerY: number, gridSize: number): {x: number, y: number}[] {
  const positions: {x: number, y: number}[] = []
  
  // 소용돌이 반지름과 각도
  let radius = 1
  let angle = Math.PI // 180도 (왼쪽부터 시작)
  const angleStep = Math.PI / 8 // 22.5도씩 회전
  const radiusIncrement = 0.3 // 더 조밀한 소용돌이
  
  while (radius < gridSize) {
    const x = Math.round(centerX + radius * Math.cos(angle))
    const y = Math.round(centerY + radius * Math.sin(angle))
    
    // 격자 범위 내에 있는 좌표만 추가
    if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
      positions.push({ x, y })
    }
    
    // 다음 위치로 이동
    angle += angleStep
    if (angle >= 2 * Math.PI) {
      angle -= 2 * Math.PI
      radius += radiusIncrement
    }
  }
  
  return positions
}

// "반복적 크기 축소 및 격자 기반 배치" 알고리즘 (백업용)
const gridSquarePlacement = (investors: any[]) => {
  console.log(`📐 반복적 크기 축소 및 격자 기반 배치 시작: ${investors.length}명`)
  
  // 1. 초기화 및 목표 크기 설정
  console.log('📊 1단계: 초기화 및 목표 크기 설정')
  
  // a. 격자 정의: 50x50 격자 (전체 셀 개수 2500개)
  const GRID_SIZE_A = 50
  const TOTAL_CELLS_A = GRID_SIZE_A * GRID_SIZE_A
  
  // b. 지분율 -> 최대 셀 개수 변환
  const squaresToPlace = investors.map((investor, index) => {
    const targetCells = Math.round(investor.share_percentage * TOTAL_CELLS_A)
    
    // c. 최대 셀 개수 -> 초기 정사각형 변 길이 변환
    // 목표 셀 개수보다 작은 제곱수 중 가장 가까운 제곱수 찾기
    let idealSide = 1
    let bestSquare = 1
    let minDifference = Math.abs(targetCells - 1)
    
    for (let side = 1; side <= GRID_SIZE_A; side++) {
      const square = side * side
      if (square < targetCells) {
        const difference = Math.abs(targetCells - square)
        if (difference < minDifference) {
          minDifference = difference
          bestSquare = square
          idealSide = side
        }
      } else {
        break
      }
    }
    
    // 만약 targetCells가 1보다 작다면 최소 크기 1×1
    if (targetCells < 1) {
      idealSide = 1
    }
    
    console.log(`  ${investor.name}: ${(investor.share_percentage * 100).toFixed(1)}% → ${targetCells}개 셀 → ${idealSide}×${idealSide} (${idealSide * idealSide}개)`)
    
    return {
      id: index,
      investor,
      originalIdealSide: idealSide,
      currentSide: idealSide,
      targetCells,
      originalShare: investor.share
    }
  })
  
  // d. originalIdealSide 기준으로 내림차순 정렬
  squaresToPlace.sort((a, b) => b.originalIdealSide - a.originalIdealSide)
  
  // 2. 반복적 배치 및 크기 조정 루프
  console.log('📊 2단계: 반복적 배치 및 크기 조정 루프')
  
  let shrinkOffset = 0
  let finalResult: Array<{
    investor: any,
    gridX: number,
    gridY: number,
    gridSize: number,
    actualCells: number
  }> = []
  
  while (true) {
    console.log(`🔄 라운드 ${shrinkOffset + 1}: shrink_offset = ${shrinkOffset}`)
    
    const placedThisRound: Array<{
      x: number,
      y: number,
      side: number,
      id: number,
      investor: any
    }> = []
    
    let allPlacedSuccessfully = true
    
    // 현재 시도할 크기 설정
    for (const sq of squaresToPlace) {
      sq.currentSide = sq.originalIdealSide - shrinkOffset
      
      // 최소 크기 체크
      if (sq.currentSide < 1) {
        console.error(`🚨 모든 사각형을 배치할 수 없습니다. 투자자가 너무 많습니다.`)
        return []
      }
    }
    
    // currentSide 기준으로 다시 내림차순 정렬
    const sortedSquares = [...squaresToPlace].sort((a, b) => b.currentSide - a.currentSide)
    
    console.log(`  현재 라운드 크기:`, sortedSquares.map(sq => `${sq.investor.name}:${sq.currentSide}×${sq.currentSide}`).join(', '))
    
    // 배치 시도 (가장 큰 currentSide부터)
    for (const sq of sortedSquares) {
      const sideToAttempt = sq.currentSide
      let found = false
      
      // 격자 내에서 배치 가능한 첫 번째 위치 찾기 (0,0부터 순차 탐색)
      outerSearch: for (let y = 0; y <= GRID_SIZE_A - sideToAttempt; y++) {
        for (let x = 0; x <= GRID_SIZE_A - sideToAttempt; x++) {
          
          // 현재 위치에 배치 가능한지 체크 (이미 배치된 사각형과 겹치지 않아야 함)
          let canPlace = true
          for (let dy = 0; dy < sideToAttempt && canPlace; dy++) {
            for (let dx = 0; dx < sideToAttempt && canPlace; dx++) {
              const checkX = x + dx
              const checkY = y + dy
              
              // 이미 배치된 사각형과 겹치는지 확인
              for (const placed of placedThisRound) {
                if (checkX >= placed.x && checkX < placed.x + placed.side &&
                    checkY >= placed.y && checkY < placed.y + placed.side) {
                  canPlace = false
                  break
                }
              }
            }
          }
          
          if (canPlace) {
            // 배치 성공
            placedThisRound.push({
              x,
              y,
              side: sideToAttempt,
              id: sq.id,
              investor: sq.investor
            })
            found = true
            console.log(`    ✅ ${sq.investor.name}: ${sideToAttempt}×${sideToAttempt} @(${x},${y})`)
            break outerSearch
          }
        }
      }
      
      if (!found) {
        console.log(`    ❌ ${sq.investor.name}: ${sideToAttempt}×${sideToAttempt} 배치 실패`)
        allPlacedSuccessfully = false
        break // 더 이상 이 라운드에서 다른 사각형 배치 시도할 필요 없음
      }
    }
    
    // 라운드 결과 확인
    if (allPlacedSuccessfully) {
      console.log(`🎉 모든 사각형이 성공적으로 배치되었습니다! (라운드 ${shrinkOffset + 1})`)
      
      // 최종 결과 변환
      finalResult = placedThisRound.map(placed => ({
        investor: placed.investor,
        gridX: placed.x,
        gridY: placed.y,
        gridSize: placed.side,
        actualCells: placed.side * placed.side
      }))
      break
    } else {
      console.log(`❌ 라운드 ${shrinkOffset + 1} 실패. 크기를 축소하여 재시도합니다.`)
      shrinkOffset++
      
      // 최대 축소 한계 체크
      const maxPossibleShrink = Math.max(...squaresToPlace.map(sq => sq.originalIdealSide)) - 1
      if (shrinkOffset > maxPossibleShrink) {
        console.error(`🚨 최대 축소 한계 도달. 배치 불가능.`)
        return []
      }
    }
  }
  
  // 3. 최종 결과 분석 및 반환
  console.log('📊 3단계: 최종 결과 분석')
  
  const totalActualCells = finalResult.reduce((sum, result) => sum + result.actualCells, 0)
  const occupancyRate = (totalActualCells / TOTAL_CELLS_A) * 100
  
  console.log(`📈 최종 격자 사용률: ${totalActualCells}/${TOTAL_CELLS_A} (${occupancyRate.toFixed(1)}%)`)
  console.log(`🎯 배치 성공률: ${finalResult.length}/${investors.length}명 (${((finalResult.length / investors.length) * 100).toFixed(1)}%)`)
  console.log(`📊 배치 결과:`)
  finalResult.forEach(result => {
    const efficiency = (result.actualCells / Math.round(result.investor.share_percentage * TOTAL_CELLS_A)) * 100
    console.log(`  ${result.investor.name}: ${result.gridSize}×${result.gridSize} (${result.actualCells}개) - 효율성 ${efficiency.toFixed(1)}%`)
  })
  
  return finalResult
}

// 투자자 영역 컴포넌트
function InvestorTerritory({ 
  investor, 
  gridX, 
  gridY, 
  gridSize, 
  continentSize 
}: { 
  investor: any,
  gridX: number,
  gridY: number,
  gridSize: number,
  continentSize: number
}) {
  const meshRef = useRef<THREE.Mesh>(null!)
  const [hovered, setHovered] = useState(false)
  const [clicked, setClicked] = useState(false)
  
  // 애니메이션 효과
  useFrame((state, delta) => {
    if (meshRef.current) {
      const targetScale = clicked ? 1.05 : (hovered ? 1.02 : 1.0)
      meshRef.current.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), delta * 8)
      
      const targetZ = hovered ? 0.12 : 0.1
      meshRef.current.position.z = THREE.MathUtils.lerp(meshRef.current.position.z, targetZ, delta * 5)
    }
  })
  
  // 격자 좌표를 실제 3D 좌표로 변환
  const cellSize = continentSize / GRID_SIZE
  const realSize = gridSize * cellSize
  const realX = (gridX + gridSize/2 - GRID_SIZE/2) * cellSize
  const realY = -(gridY + gridSize/2 - GRID_SIZE/2) * cellSize // Y축 뒤집기
  
  return (
    <group position={[realX, realY, 0.5]}>
      {/* 조건부 렌더링: 이미지가 있으면 이미지만, 없으면 색상만 */}
      {investor.imageUrl ? (
        /* 투자자 이미지 (이미지가 있을 때) */
        <InvestorImage 
          imageUrl={investor.imageUrl}
          cellSize={realSize * 0.95}
          investorName={investor.name}
          hovered={hovered}
          clicked={clicked}
          onPointerOver={() => setHovered(true)}
          onPointerOut={() => setHovered(false)}
          onClick={() => {
            setClicked(!clicked)
            console.log(`🎯 ${investor.name} 클릭: ${gridSize}×${gridSize} 격자 (${gridSize * gridSize}개 셀)`)
          }}
        />
      ) : (
        /* 영역 배경 색상 (이미지가 없을 때) */
        <mesh 
          ref={meshRef}
          position={[0, 0, 0.1]}
          onPointerOver={() => setHovered(true)}
          onPointerOut={() => setHovered(false)}
          onClick={() => {
            setClicked(!clicked)
            console.log(`🎯 ${investor.name} 클릭: ${gridSize}×${gridSize} 격자 (${gridSize * gridSize}개 셀)`)
          }}
        >
          <boxGeometry args={[realSize * 0.95, realSize * 0.95, 0.2]} />
          <meshStandardMaterial 
            color={investor.color}
            opacity={hovered ? 1.0 : 0.9}
            transparent={!hovered}
            roughness={0.3}
            metalness={0.1}
          />
        </mesh>
      )}
    </group>
  )
}

// 50x50 격자선 컴포넌트
function GridLines({ continentSize = 20 }: { continentSize?: number }) {
  const cellSize = continentSize / GRID_SIZE
  const halfSize = continentSize / 2
  
  return (
    <group position={[0, 0, 0.6]}> {/* 대륙보다 약간 위에 */}
      {/* 수직선들 (51개) */}
      {Array.from({ length: GRID_SIZE + 1 }, (_, i) => {
        const x = -halfSize + i * cellSize
        return (
          <mesh key={`vertical-${i}`} position={[x, 0, 0]}>
            <boxGeometry args={[0.05, continentSize, 0.01]} />
            <meshBasicMaterial color="#ffffff" opacity={0.3} transparent />
          </mesh>
        )
      })}
      
      {/* 수평선들 (51개) */}
      {Array.from({ length: GRID_SIZE + 1 }, (_, i) => {
        const y = -halfSize + i * cellSize
        return (
          <mesh key={`horizontal-${i}`} position={[0, y, 0]}>
            <boxGeometry args={[continentSize, 0.05, 0.01]} />
            <meshBasicMaterial color="#ffffff" opacity={0.3} transparent />
          </mesh>
        )
      })}
    </group>
  )
}

// 투자자 영역 시스템 메인 컴포넌트
function InvestorTerritories({ 
  investors, 
  continentSize = 20 
}: { 
  investors: Record<string, any>,
  continentSize?: number
}) {
  const investorsList = Object.values(investors)
  
  const placedSquares = investorsList.length > 0 ? spiralPlacement(investorsList) : []
  
  return (
    <group>
      {/* 항상 격자선 표시 */}
      <GridLines continentSize={continentSize} />
      
      {/* 투자자 영역들 */}
      {placedSquares.map((square, index) => (
        <InvestorTerritory
          key={square.investor.id}
          investor={square.investor}
          gridX={square.gridX}
          gridY={square.gridY}
          gridSize={square.gridSize}
          continentSize={continentSize}
        />
      ))}
    </group>
  )
}

// 투자자 이미지 컴포넌트 (원본 비율 유지)
function InvestorImage({ 
  imageUrl, 
  cellSize,
  investorName,
  hovered,
  clicked,
  onPointerOver,
  onPointerOut,
  onClick
}: { 
  imageUrl?: string,
  cellSize: number,
  investorName: string,
  hovered?: boolean,
  clicked?: boolean,
  onPointerOver?: () => void,
  onPointerOut?: () => void,
  onClick?: () => void
}) {
  // 텍스처 로드 (임시로 test.jpg 사용, 나중에 imageUrl 사용 예정)
  const texture = useMemo(() => {
    const loader = new THREE.TextureLoader()
    // TODO: 나중에 실제 사용자 이미지로 변경
    const imagePath = imageUrl || '/test.jpg'
    const tex = loader.load(
      imagePath,
      (texture) => {
        console.log(`✅ ${investorName} 이미지 로드 성공:`, imagePath)
      },
      undefined,
      (error) => {
        console.error(`❌ ${investorName} 이미지 로드 실패:`, error)
      }
    )
    tex.wrapS = THREE.ClampToEdgeWrapping
    tex.wrapT = THREE.ClampToEdgeWrapping
    return tex
  }, [imageUrl, investorName])

  // 애니메이션을 위한 ref
  const meshRef = useRef<THREE.Mesh>(null)

  // 애니메이션 효과 (mesh와 동일한 로직)
  useFrame(() => {
    if (meshRef.current) {
      // 호버 효과: 크기 변화 (1.05배)
      const targetScale = hovered ? 1.05 : 1.0
      const currentScale = meshRef.current.scale.x
      const lerpScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1)
      meshRef.current.scale.setScalar(lerpScale)
      
      // 클릭 효과: 위치 변화 (0.2 위로)
      const targetZ = clicked ? 0.4 : 0.2
      const currentZ = meshRef.current.position.z
      const lerpZ = THREE.MathUtils.lerp(currentZ, targetZ, 0.1)
      meshRef.current.position.z = lerpZ
    }
  })

  // 이미지 크기 = 영역 크기와 정확히 동일
  const imageSize = useMemo(() => {
    // 영역 크기와 정확히 같은 크기로 설정 (Cover 방식)
    return [cellSize, cellSize]
  }, [cellSize])

  return (
    <mesh 
      ref={meshRef}
      position={[0, 0, 0.2]}
      onPointerOver={onPointerOver}
      onPointerOut={onPointerOut}
      onClick={onClick}
    >
      <planeGeometry args={[imageSize[0], imageSize[1]]} />
      <meshBasicMaterial 
        map={texture}
        transparent={false}
        opacity={1.0}
      />
    </mesh>
  )
}



function SingleContinent({ continent }: { continent: Continent }) {
  const [x, y, z] = continent.position
  const { generateTestData } = useContinentStore()
  
  // 실제 투자자 데이터 - 스토어에서 가져옴
  const investors = continent.investors
  
  // 테스트용: 중앙 대륙에 50명 배치 (각자 2% 지분, $200 투자)
  // 한 번만 실행되도록 useEffect 대신 조건부 실행
  if (continent.id === 'center' && Object.keys(investors).length === 0) {
    // 스토어에 테스트 데이터 생성
    generateTestData('center')
  }
  
  return (
    <group position={[x, y, z]}>
      {/* 대륙 베이스 - 단순한 사각형 (크기 증가) */}
      <mesh position={[0, 0, 0]}>
        <boxGeometry args={[20, 20, 0.8]} />
        <meshStandardMaterial 
          color={continent.color} 
          opacity={1.0} 
          transparent={false} 
          roughness={0.6}
          metalness={0.2}
        />
      </mesh>
      
      {/* 50x50 격자 기반 투자자 영역 표시 (격자선 항상 표시) */}
      <InvestorTerritories investors={investors} continentSize={20} />
    </group>
  )
}

function WorldScene() {
  const { continents } = useContinentStore()

  return (
    <group>
      {/* 전역 조명 */}
      <ambientLight intensity={0.5} />
      <pointLight position={[20, 20, 20]} intensity={1} />
      <pointLight position={[-20, -20, 20]} intensity={0.5} />
      
      {/* 모든 대륙 렌더링 */}
      {Object.values(continents).map((continent) => (
        <SingleContinent key={continent.id} continent={continent} />
      ))}
    </group>
  )
}

export default function ContinentMap() {
  const { selectedContinent, continents, isWorldView } = useContinentStore()
  
  // 현재 선택된 대륙 정보 (있으면 해당 대륙, 없으면 중앙 대륙)
  const displayContinent = selectedContinent ? continents[selectedContinent] : continents.center
  
  return (
    <main className="w-full h-screen" style={{ backgroundColor: '#37aff7' }}>
      {/* 3D Canvas */}
      <Canvas 
        camera={{ 
          position: [0, 0, 60], // 30 → 60 (2배) 
          fov: 75 
        }}
        className="w-full h-full"
        style={{ cursor: 'grab' }}
      >
        <CameraController />
        <WorldScene />
      </Canvas>
      
      {/* 우상단 정보 */}
      <div className="absolute top-20 right-4 text-white bg-black bg-opacity-80 p-4 rounded-lg">
        <h2 className="font-bold" style={{ color: displayContinent.color }}>
          {isWorldView ? '세계 지도' : displayContinent.name}
        </h2>
        <div className="text-sm mt-2">
          {isWorldView ? (
            <>
              <p>🌍 전체 5개 대륙</p>
              <p>📊 총 사용자: {Object.values(continents).reduce((sum, c) => sum + c.currentUsers, 0)}명</p>
            </>
          ) : (
            <>
              <p>👥 사용자: {displayContinent.currentUsers}/{displayContinent.maxUsers}</p>
              <p>💰 총 투자금: ₩0</p>
            </>
          )}
          <p className="text-xs text-gray-400 mt-1">Stage 1-3: 세계 지도 시스템</p>
        </div>
      </div>
    </main>
  )
} 