'use client'

import { Canvas, useThree, useFrame } from '@react-three/fiber'
import { useRef, useState, useCallback, useEffect, useMemo } from 'react'
import * as THREE from 'three'
import { useContinentStore, type Continent } from '@/store/continentStore'
import { spiralPlacement } from '@/utils/spiralPlacement'
import { spiralPlacement } from '@/utils/spiralPlacement'

function CameraController() {
  const { camera, gl } = useThree()
  const { selectedContinent, continents, isWorldView, setSelectedContinent, setWorldView, cameraTarget, setCameraTarget } = useContinentStore()
  
  const [isDragging, setIsDragging] = useState(false)
  const previousMouse = useRef({ x: 0, y: 0 })
  const cameraPosition = useRef(new THREE.Vector3(0, 0, 60)) // 30 â†’ 60 (2ë°°)
  const targetPosition = useRef(new THREE.Vector3(0, 0, 60)) // 30 â†’ 60 (2ë°°)
  
  // ë“œë¡­ë‹¤ìš´ ì„ íƒì— ë”°ë¥¸ ì¹´ë©”ë¼ ì´ë™ ì²˜ë¦¬
  useEffect(() => {
    if (cameraTarget) {
      const [x, y, z] = cameraTarget
      console.log('ë“œë¡­ë‹¤ìš´ ì„ íƒìœ¼ë¡œ ì¹´ë©”ë¼ ì´ë™:', x, y, z)
      targetPosition.current.set(x, y, z)
      setCameraTarget(null) // ì´ë™ ì™„ë£Œ í›„ íƒ€ê²Ÿ ì´ˆê¸°í™”
    }
  }, [cameraTarget, setCameraTarget])
  
  // í˜„ì¬ ìœ„ì¹˜ ê¸°ë°˜ ë“œë¡­ë‹¤ìš´ ë°˜ì˜ í•¨ìˆ˜ (í¬ì»¤ì‹± ì—†ìŒ)
  const updateDropdownBasedOnPosition = useCallback(() => {
    if (isDragging) return // ë“œë˜ê·¸ ì¤‘ì—ëŠ” ì—…ë°ì´íŠ¸ ì•ˆí•¨

    const currentPos = camera.position
    let nearestContinent: string | null = null
    let minDistance = Infinity
    
    Object.values(continents).forEach((continent) => {
      const [x, y, z] = continent.position
      const distance = Math.sqrt(
        Math.pow(currentPos.x - x, 2) + 
        Math.pow(currentPos.y - y, 2)
      )
      
      if (distance < minDistance && distance < 30) { // 30 ë‹¨ìœ„ ë‚´ì—ì„œë§Œ ê°ì§€ (15â†’30)
        minDistance = distance
        nearestContinent = continent.id
      }
    })
    
    // ë“œë¡­ë‹¤ìš´ë§Œ ë³€ê²½, ì¹´ë©”ë¼ ì´ë™ ì—†ìŒ
    if (nearestContinent && nearestContinent !== selectedContinent) {
      const continent = continents[nearestContinent as keyof typeof continents]
      console.log('ìœ„ì¹˜ ê¸°ë°˜ ë“œë¡­ë‹¤ìš´ ë³€ê²½:', continent.name)
      setSelectedContinent(nearestContinent as any)
      setWorldView(false)
    } else if (!nearestContinent && !isWorldView) {
      console.log('ì„¸ê³„ ì§€ë„ë¡œ ë“œë¡­ë‹¤ìš´ ë³€ê²½')
      setWorldView(true)
    }
  }, [camera, continents, selectedContinent, isWorldView, isDragging, setSelectedContinent, setWorldView])
  
  // Canvas ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ì„¤ì • - ì „ì—­ ì´ë²¤íŠ¸ë¡œ ìˆ˜ì •
  useEffect(() => {
    const canvas = gl.domElement
    
    const handlePointerDown = (event: PointerEvent) => {
      setIsDragging(true)
      previousMouse.current = { x: event.clientX, y: event.clientY }
      canvas.style.cursor = 'grabbing'
      event.preventDefault()
    }
    
    // ì „ì—­ì—ì„œ pointermoveì™€ pointerup ì²˜ë¦¬ (ë“œë˜ê·¸ ìƒíƒœ ìœ ì§€)
    const handlePointerMove = (event: PointerEvent) => {
      if (!isDragging) return
      
      const deltaX = event.clientX - previousMouse.current.x
      const deltaY = event.clientY - previousMouse.current.y
      
      // ì´ë™ ë°©í–¥ì„ ë§ˆìš°ìŠ¤ì™€ ë°˜ëŒ€ë¡œ - ì§€ë„ë¥¼ ì¡ì•„ë‹¹ê¸°ëŠ” ëŠë‚Œ (ì†ë„ 1.5ë°° ì¦ê°€)
      const sensitivity = 0.015 // 0.01 -> 0.015ë¡œ 1.5ë°° ì¦ê°€
      targetPosition.current.x -= deltaX * sensitivity  // ë§ˆìš°ìŠ¤ ë°˜ëŒ€ ë°©í–¥
      targetPosition.current.y += deltaY * sensitivity  // ë§ˆìš°ìŠ¤ ë°˜ëŒ€ ë°©í–¥
      
      previousMouse.current = { x: event.clientX, y: event.clientY }
      event.preventDefault()
    }
    
    const handlePointerUp = (event: PointerEvent) => {
      if (isDragging) {
        setIsDragging(false)
        canvas.style.cursor = 'grab'
        event.preventDefault()
      }
    }
    
    const handleWheel = (event: WheelEvent) => {
      event.preventDefault()
      // ì¤Œ ì†ë„ ì¦ê°€ (0.002 -> 0.008ë¡œ 4ë°° ì¦ê°€)
      const zoomSpeed = 0.008
      targetPosition.current.z += event.deltaY * zoomSpeed
      targetPosition.current.z = Math.max(15, Math.min(120, targetPosition.current.z)) // 5-50 â†’ 15-120
    }
    
    // Canvasì—ëŠ” pointerdownê³¼ wheelë§Œ
    canvas.addEventListener('pointerdown', handlePointerDown)
    canvas.addEventListener('wheel', handleWheel)
    
    // ì „ì—­ì—ëŠ” pointermoveì™€ pointerup (ë“œë˜ê·¸ ìƒíƒœ ìœ ì§€)
    document.addEventListener('pointermove', handlePointerMove)
    document.addEventListener('pointerup', handlePointerUp)
    
    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown)
      canvas.removeEventListener('wheel', handleWheel)
      document.removeEventListener('pointermove', handlePointerMove)
      document.removeEventListener('pointerup', handlePointerUp)
    }
  }, [gl, isDragging])
  
  useFrame(() => {
    // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì´ë™ - ì†ë„ ì¦ê°€
    cameraPosition.current.lerp(targetPosition.current, 0.12) // 0.08 -> 0.12ë¡œ ì†ë„ ì¦ê°€
    camera.position.copy(cameraPosition.current)
    
    // í˜„ì¬ ìœ„ì¹˜ ê¸°ë°˜ ë“œë¡­ë‹¤ìš´ ì—…ë°ì´íŠ¸ (í¬ì»¤ì‹± ì—†ìŒ)
    updateDropdownBasedOnPosition()
  })
  
  return null
}

// 50x50 ê²©ì ê¸°ë°˜ ì •ì‚¬ê°í˜• ë°°ì¹˜ ì‹œìŠ¤í…œ
const GRID_SIZE = 50 // 50x50 ê²©ì
const TOTAL_CELLS = GRID_SIZE * GRID_SIZE // 2500ê°œ ì…€

// ì§€ë¶„ì„ ê²©ì ê°œìˆ˜ë¡œ ë³€í™˜
const shareToGridCount = (share: number): number => {
  return Math.round(share * TOTAL_CELLS)
}

// ê²©ì ê°œìˆ˜ë¥¼ ê°€ì¥ ê°€ê¹Œìš´ ì œê³±ìˆ˜ë¡œ ë³€í™˜ (50x50 ì •ë°€ ë²„ì „)
const gridCountToSquareSize = (gridCount: number): number => {
  // ëª©í‘œ ê²©ì ê°œìˆ˜ë³´ë‹¤ ì‘ì€ ì œê³±ìˆ˜ë“¤ì„ ëª¨ë‘ ìƒì„±
  const perfectSquares = []
  for (let i = 1; i * i < gridCount && i * i <= TOTAL_CELLS; i++) {
    perfectSquares.push(i * i)
  }
  
  // ë¹ˆ ë°°ì—´ì´ë©´ ìµœì†Œ í¬ê¸° 1Ã—1 ë°˜í™˜
  if (perfectSquares.length === 0) {
    return 1
  }
  
  // ëª©í‘œ ê²©ì ê°œìˆ˜ì™€ ê°€ì¥ ê°€ê¹Œìš´ ì œê³±ìˆ˜ ì°¾ê¸°
  let bestSquare = perfectSquares[0]
  let minDifference = Math.abs(gridCount - bestSquare)
  
  for (const square of perfectSquares) {
    const difference = Math.abs(gridCount - square)
    if (difference < minDifference) {
      minDifference = difference
      bestSquare = square
    }
  }
  
  return Math.sqrt(bestSquare) // í•œ ë³€ì˜ ê¸¸ì´ ë°˜í™˜
}



// "ì†Œìš©ëŒì´ ë°°ì¹˜" ì•Œê³ ë¦¬ì¦˜
const spiralPlacement = (investors: any[]) => {
  console.log(`ğŸŒ€ ì†Œìš©ëŒì´ ë°°ì¹˜ ì‹œì‘: ${investors.length}ëª…`)
  
  if (investors.length === 0) return []
  
  // 1. íˆ¬ììë“¤ì„ ì§€ë¶„ í¬ê¸° ìˆœìœ¼ë¡œ ì •ë ¬ (í° ê²ƒë¶€í„°)
  const sortedInvestors = [...investors].sort((a, b) => b.share - a.share)
  console.log('ğŸ“Š í¬ê¸° ìˆœ ì •ë ¬:', sortedInvestors.map(inv => `${inv.name}: ${inv.share.toFixed(1)}%`))
  
  // 2. ê° íˆ¬ììì˜ í¬ê¸° ê³„ì‚° (ì§€ë¶„ì— ë”°ë¥¸ ì •ì‚¬ê°í˜• í¬ê¸°)
  const investorSizes = sortedInvestors.map(investor => {
    const targetCells = Math.round(investor.share_percentage * TOTAL_CELLS)
    const side = Math.max(1, Math.floor(Math.sqrt(targetCells)))
    return {
      investor,
      size: side,
      targetCells
    }
  })
  
  // 3. 50x50 ê²©ìì— ì†Œìš©ëŒì´ ë°°ì¹˜
  const occupied = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false))
  const placedSquares: any[] = []
  const centerX = Math.floor(GRID_SIZE / 2)
  const centerY = Math.floor(GRID_SIZE / 2)
  
  console.log(`ğŸ¯ ì¤‘ì‹¬ì : (${centerX}, ${centerY})`)
  
  for (let i = 0; i < investorSizes.length; i++) {
    const { investor, size } = investorSizes[i]
    let placed = false
    
    if (i === 0) {
      // ê°€ì¥ í° íˆ¬ììë¥¼ ì¤‘ì‹¬ì— ë°°ì¹˜
      const startX = centerX - Math.floor(size / 2)
      const startY = centerY - Math.floor(size / 2)
      
      if (canPlaceAt(occupied, startX, startY, size)) {
        placeAt(occupied, startX, startY, size)
        placedSquares.push({
          investor,
          gridX: startX,
          gridY: startY,
          gridSize: size
        })
        console.log(`ğŸ¯ ì¤‘ì‹¬ ë°°ì¹˜: ${investor.name} ${size}Ã—${size} â†’ (${startX}, ${startY})`)
        placed = true
      }
    } else {
      // ë‚˜ë¨¸ì§€ëŠ” ì†Œìš©ëŒì´ íŒ¨í„´ìœ¼ë¡œ ë°°ì¹˜
      const spiralPositions = generateSpiralPositions(centerX, centerY, GRID_SIZE)
      
      for (const pos of spiralPositions) {
        const startX = pos.x - Math.floor(size / 2)
        const startY = pos.y - Math.floor(size / 2)
        
        if (canPlaceAt(occupied, startX, startY, size)) {
          placeAt(occupied, startX, startY, size)
          placedSquares.push({
            investor,
            gridX: startX,
            gridY: startY,
            gridSize: size
          })
          console.log(`ğŸŒ€ ì†Œìš©ëŒì´ ë°°ì¹˜: ${investor.name} ${size}Ã—${size} â†’ (${startX}, ${startY})`)
          placed = true
          break
        }
      }
    }
    
    if (!placed) {
      console.log(`âŒ ë°°ì¹˜ ì‹¤íŒ¨: ${investor.name}, 1Ã—1ë¡œ ì¶•ì†Œ ì‹œë„`)
      // ë°°ì¹˜ ì‹¤íŒ¨ì‹œ 1Ã—1ë¡œ ì¶•ì†Œí•´ì„œ ì¬ì‹œë„
      const spiralPositions = generateSpiralPositions(centerX, centerY, GRID_SIZE)
      for (const pos of spiralPositions) {
        if (canPlaceAt(occupied, pos.x, pos.y, 1)) {
          placeAt(occupied, pos.x, pos.y, 1)
          placedSquares.push({
            investor,
            gridX: pos.x,
            gridY: pos.y,
            gridSize: 1
          })
          console.log(`ğŸ”§ 1Ã—1 ë°°ì¹˜: ${investor.name} â†’ (${pos.x}, ${pos.y})`)
          break
        }
      }
    }
  }
  
  console.log(`ğŸŒ€ ì†Œìš©ëŒì´ ë°°ì¹˜ ì™„ë£Œ: ${placedSquares.length}ê°œ`)
  return placedSquares
}

// ë°°ì¹˜ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
function canPlaceAt(occupied: boolean[][], startX: number, startY: number, size: number): boolean {
  if (startX < 0 || startY < 0 || startX + size > GRID_SIZE || startY + size > GRID_SIZE) {
    return false
  }
  
  for (let y = startY; y < startY + size; y++) {
    for (let x = startX; x < startX + size; x++) {
      if (occupied[y][x]) {
        return false
      }
    }
  }
  return true
}

// ê²©ìì— ë°°ì¹˜í•˜ê¸°
function placeAt(occupied: boolean[][], startX: number, startY: number, size: number): void {
  for (let y = startY; y < startY + size; y++) {
    for (let x = startX; x < startX + size; x++) {
      occupied[y][x] = true
    }
  }
}

// ì†Œìš©ëŒì´ íŒ¨í„´ ì¢Œí‘œ ìƒì„± (ì¤‘ì‹¬ì—ì„œ ì‹œì‘í•´ì„œ ì‹œê³„ë°©í–¥ìœ¼ë¡œ)
function generateSpiralPositions(centerX: number, centerY: number, gridSize: number): {x: number, y: number}[] {
  const positions: {x: number, y: number}[] = []
  
  // ì†Œìš©ëŒì´ ë°˜ì§€ë¦„ê³¼ ê°ë„
  let radius = 1
  let angle = Math.PI // 180ë„ (ì™¼ìª½ë¶€í„° ì‹œì‘)
  const angleStep = Math.PI / 8 // 22.5ë„ì”© íšŒì „
  const radiusIncrement = 0.3 // ë” ì¡°ë°€í•œ ì†Œìš©ëŒì´
  
  while (radius < gridSize) {
    const x = Math.round(centerX + radius * Math.cos(angle))
    const y = Math.round(centerY + radius * Math.sin(angle))
    
    // ê²©ì ë²”ìœ„ ë‚´ì— ìˆëŠ” ì¢Œí‘œë§Œ ì¶”ê°€
    if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
      positions.push({ x, y })
    }
    
    // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
    angle += angleStep
    if (angle >= 2 * Math.PI) {
      angle -= 2 * Math.PI
      radius += radiusIncrement
    }
  }
  
  return positions
}

// "ë°˜ë³µì  í¬ê¸° ì¶•ì†Œ ë° ê²©ì ê¸°ë°˜ ë°°ì¹˜" ì•Œê³ ë¦¬ì¦˜ (ë°±ì—…ìš©)
const gridSquarePlacement = (investors: any[]) => {
  console.log(`ğŸ“ ë°˜ë³µì  í¬ê¸° ì¶•ì†Œ ë° ê²©ì ê¸°ë°˜ ë°°ì¹˜ ì‹œì‘: ${investors.length}ëª…`)
  
  // 1. ì´ˆê¸°í™” ë° ëª©í‘œ í¬ê¸° ì„¤ì •
  console.log('ğŸ“Š 1ë‹¨ê³„: ì´ˆê¸°í™” ë° ëª©í‘œ í¬ê¸° ì„¤ì •')
  
  // a. ê²©ì ì •ì˜: 50x50 ê²©ì (ì „ì²´ ì…€ ê°œìˆ˜ 2500ê°œ)
  const GRID_SIZE_A = 50
  const TOTAL_CELLS_A = GRID_SIZE_A * GRID_SIZE_A
  
  // b. ì§€ë¶„ìœ¨ -> ìµœëŒ€ ì…€ ê°œìˆ˜ ë³€í™˜
  const squaresToPlace = investors.map((investor, index) => {
    const targetCells = Math.round(investor.share_percentage * TOTAL_CELLS_A)
    
    // c. ìµœëŒ€ ì…€ ê°œìˆ˜ -> ì´ˆê¸° ì •ì‚¬ê°í˜• ë³€ ê¸¸ì´ ë³€í™˜
    // ëª©í‘œ ì…€ ê°œìˆ˜ë³´ë‹¤ ì‘ì€ ì œê³±ìˆ˜ ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ ì œê³±ìˆ˜ ì°¾ê¸°
    let idealSide = 1
    let bestSquare = 1
    let minDifference = Math.abs(targetCells - 1)
    
    for (let side = 1; side <= GRID_SIZE_A; side++) {
      const square = side * side
      if (square < targetCells) {
        const difference = Math.abs(targetCells - square)
        if (difference < minDifference) {
          minDifference = difference
          bestSquare = square
          idealSide = side
        }
      } else {
        break
      }
    }
    
    // ë§Œì•½ targetCellsê°€ 1ë³´ë‹¤ ì‘ë‹¤ë©´ ìµœì†Œ í¬ê¸° 1Ã—1
    if (targetCells < 1) {
      idealSide = 1
    }
    
    console.log(`  ${investor.name}: ${(investor.share_percentage * 100).toFixed(1)}% â†’ ${targetCells}ê°œ ì…€ â†’ ${idealSide}Ã—${idealSide} (${idealSide * idealSide}ê°œ)`)
    
    return {
      id: index,
      investor,
      originalIdealSide: idealSide,
      currentSide: idealSide,
      targetCells,
      originalShare: investor.share
    }
  })
  
  // d. originalIdealSide ê¸°ì¤€ìœ¼ë¡œ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
  squaresToPlace.sort((a, b) => b.originalIdealSide - a.originalIdealSide)
  
  // 2. ë°˜ë³µì  ë°°ì¹˜ ë° í¬ê¸° ì¡°ì • ë£¨í”„
  console.log('ğŸ“Š 2ë‹¨ê³„: ë°˜ë³µì  ë°°ì¹˜ ë° í¬ê¸° ì¡°ì • ë£¨í”„')
  
  let shrinkOffset = 0
  let finalResult: Array<{
    investor: any,
    gridX: number,
    gridY: number,
    gridSize: number,
    actualCells: number
  }> = []
  
  while (true) {
    console.log(`ğŸ”„ ë¼ìš´ë“œ ${shrinkOffset + 1}: shrink_offset = ${shrinkOffset}`)
    
    const placedThisRound: Array<{
      x: number,
      y: number,
      side: number,
      id: number,
      investor: any
    }> = []
    
    let allPlacedSuccessfully = true
    
    // í˜„ì¬ ì‹œë„í•  í¬ê¸° ì„¤ì •
    for (const sq of squaresToPlace) {
      sq.currentSide = sq.originalIdealSide - shrinkOffset
      
      // ìµœì†Œ í¬ê¸° ì²´í¬
      if (sq.currentSide < 1) {
        console.error(`ğŸš¨ ëª¨ë“  ì‚¬ê°í˜•ì„ ë°°ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. íˆ¬ììê°€ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤.`)
        return []
      }
    }
    
    // currentSide ê¸°ì¤€ìœ¼ë¡œ ë‹¤ì‹œ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
    const sortedSquares = [...squaresToPlace].sort((a, b) => b.currentSide - a.currentSide)
    
    console.log(`  í˜„ì¬ ë¼ìš´ë“œ í¬ê¸°:`, sortedSquares.map(sq => `${sq.investor.name}:${sq.currentSide}Ã—${sq.currentSide}`).join(', '))
    
    // ë°°ì¹˜ ì‹œë„ (ê°€ì¥ í° currentSideë¶€í„°)
    for (const sq of sortedSquares) {
      const sideToAttempt = sq.currentSide
      let found = false
      
      // ê²©ì ë‚´ì—ì„œ ë°°ì¹˜ ê°€ëŠ¥í•œ ì²« ë²ˆì§¸ ìœ„ì¹˜ ì°¾ê¸° (0,0ë¶€í„° ìˆœì°¨ íƒìƒ‰)
      outerSearch: for (let y = 0; y <= GRID_SIZE_A - sideToAttempt; y++) {
        for (let x = 0; x <= GRID_SIZE_A - sideToAttempt; x++) {
          
          // í˜„ì¬ ìœ„ì¹˜ì— ë°°ì¹˜ ê°€ëŠ¥í•œì§€ ì²´í¬ (ì´ë¯¸ ë°°ì¹˜ëœ ì‚¬ê°í˜•ê³¼ ê²¹ì¹˜ì§€ ì•Šì•„ì•¼ í•¨)
          let canPlace = true
          for (let dy = 0; dy < sideToAttempt && canPlace; dy++) {
            for (let dx = 0; dx < sideToAttempt && canPlace; dx++) {
              const checkX = x + dx
              const checkY = y + dy
              
              // ì´ë¯¸ ë°°ì¹˜ëœ ì‚¬ê°í˜•ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
              for (const placed of placedThisRound) {
                if (checkX >= placed.x && checkX < placed.x + placed.side &&
                    checkY >= placed.y && checkY < placed.y + placed.side) {
                  canPlace = false
                  break
                }
              }
            }
          }
          
          if (canPlace) {
            // ë°°ì¹˜ ì„±ê³µ
            placedThisRound.push({
              x,
              y,
              side: sideToAttempt,
              id: sq.id,
              investor: sq.investor
            })
            found = true
            console.log(`    âœ… ${sq.investor.name}: ${sideToAttempt}Ã—${sideToAttempt} @(${x},${y})`)
            break outerSearch
          }
        }
      }
      
      if (!found) {
        console.log(`    âŒ ${sq.investor.name}: ${sideToAttempt}Ã—${sideToAttempt} ë°°ì¹˜ ì‹¤íŒ¨`)
        allPlacedSuccessfully = false
        break // ë” ì´ìƒ ì´ ë¼ìš´ë“œì—ì„œ ë‹¤ë¥¸ ì‚¬ê°í˜• ë°°ì¹˜ ì‹œë„í•  í•„ìš” ì—†ìŒ
      }
    }
    
    // ë¼ìš´ë“œ ê²°ê³¼ í™•ì¸
    if (allPlacedSuccessfully) {
      console.log(`ğŸ‰ ëª¨ë“  ì‚¬ê°í˜•ì´ ì„±ê³µì ìœ¼ë¡œ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤! (ë¼ìš´ë“œ ${shrinkOffset + 1})`)
      
      // ìµœì¢… ê²°ê³¼ ë³€í™˜
      finalResult = placedThisRound.map(placed => ({
        investor: placed.investor,
        gridX: placed.x,
        gridY: placed.y,
        gridSize: placed.side,
        actualCells: placed.side * placed.side
      }))
      break
    } else {
      console.log(`âŒ ë¼ìš´ë“œ ${shrinkOffset + 1} ì‹¤íŒ¨. í¬ê¸°ë¥¼ ì¶•ì†Œí•˜ì—¬ ì¬ì‹œë„í•©ë‹ˆë‹¤.`)
      shrinkOffset++
      
      // ìµœëŒ€ ì¶•ì†Œ í•œê³„ ì²´í¬
      const maxPossibleShrink = Math.max(...squaresToPlace.map(sq => sq.originalIdealSide)) - 1
      if (shrinkOffset > maxPossibleShrink) {
        console.error(`ğŸš¨ ìµœëŒ€ ì¶•ì†Œ í•œê³„ ë„ë‹¬. ë°°ì¹˜ ë¶ˆê°€ëŠ¥.`)
        return []
      }
    }
  }
  
  // 3. ìµœì¢… ê²°ê³¼ ë¶„ì„ ë° ë°˜í™˜
  console.log('ğŸ“Š 3ë‹¨ê³„: ìµœì¢… ê²°ê³¼ ë¶„ì„')
  
  const totalActualCells = finalResult.reduce((sum, result) => sum + result.actualCells, 0)
  const occupancyRate = (totalActualCells / TOTAL_CELLS_A) * 100
  
  console.log(`ğŸ“ˆ ìµœì¢… ê²©ì ì‚¬ìš©ë¥ : ${totalActualCells}/${TOTAL_CELLS_A} (${occupancyRate.toFixed(1)}%)`)
  console.log(`ğŸ¯ ë°°ì¹˜ ì„±ê³µë¥ : ${finalResult.length}/${investors.length}ëª… (${((finalResult.length / investors.length) * 100).toFixed(1)}%)`)
  console.log(`ğŸ“Š ë°°ì¹˜ ê²°ê³¼:`)
  finalResult.forEach(result => {
    const efficiency = (result.actualCells / Math.round(result.investor.share_percentage * TOTAL_CELLS_A)) * 100
    console.log(`  ${result.investor.name}: ${result.gridSize}Ã—${result.gridSize} (${result.actualCells}ê°œ) - íš¨ìœ¨ì„± ${efficiency.toFixed(1)}%`)
  })
  
  return finalResult
}

// íˆ¬ìì ì˜ì—­ ì»´í¬ë„ŒíŠ¸
function InvestorTerritory({ 
  investor, 
  gridX, 
  gridY, 
  gridSize, 
  continentSize 
}: { 
  investor: any,
  gridX: number,
  gridY: number,
  gridSize: number,
  continentSize: number
}) {
  const meshRef = useRef<THREE.Mesh>(null!)
  const [hovered, setHovered] = useState(false)
  const [clicked, setClicked] = useState(false)
  
  // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
  useFrame((state, delta) => {
    if (meshRef.current) {
      const targetScale = clicked ? 1.05 : (hovered ? 1.02 : 1.0)
      meshRef.current.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), delta * 8)
      
      const targetZ = hovered ? 0.12 : 0.1
      meshRef.current.position.z = THREE.MathUtils.lerp(meshRef.current.position.z, targetZ, delta * 5)
    }
  })
  
  // ê²©ì ì¢Œí‘œë¥¼ ì‹¤ì œ 3D ì¢Œí‘œë¡œ ë³€í™˜
  const cellSize = continentSize / GRID_SIZE
  const realSize = gridSize * cellSize
  const realX = (gridX + gridSize/2 - GRID_SIZE/2) * cellSize
  const realY = -(gridY + gridSize/2 - GRID_SIZE/2) * cellSize // Yì¶• ë’¤ì§‘ê¸°
  
  return (
    <group position={[realX, realY, 0.5]}>
      {/* ì¡°ê±´ë¶€ ë Œë”ë§: ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì´ë¯¸ì§€ë§Œ, ì—†ìœ¼ë©´ ìƒ‰ìƒë§Œ */}
      {investor.imageUrl ? (
        /* íˆ¬ìì ì´ë¯¸ì§€ (ì´ë¯¸ì§€ê°€ ìˆì„ ë•Œ) */
        <InvestorImage 
          imageUrl={investor.imageUrl}
          cellSize={realSize * 0.95}
          investorName={investor.name}
          hovered={hovered}
          clicked={clicked}
          onPointerOver={() => setHovered(true)}
          onPointerOut={() => setHovered(false)}
          onClick={() => {
            setClicked(!clicked)
            console.log(`ğŸ¯ ${investor.name} í´ë¦­: ${gridSize}Ã—${gridSize} ê²©ì (${gridSize * gridSize}ê°œ ì…€)`)
          }}
        />
      ) : (
        /* ì˜ì—­ ë°°ê²½ ìƒ‰ìƒ (ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œ) */
        <mesh 
          ref={meshRef}
          position={[0, 0, 0.1]}
          onPointerOver={() => setHovered(true)}
          onPointerOut={() => setHovered(false)}
          onClick={() => {
            setClicked(!clicked)
            console.log(`ğŸ¯ ${investor.name} í´ë¦­: ${gridSize}Ã—${gridSize} ê²©ì (${gridSize * gridSize}ê°œ ì…€)`)
          }}
        >
          <boxGeometry args={[realSize * 0.95, realSize * 0.95, 0.2]} />
          <meshStandardMaterial 
            color={investor.color}
            opacity={hovered ? 1.0 : 0.9}
            transparent={!hovered}
            roughness={0.3}
            metalness={0.1}
          />
        </mesh>
      )}
    </group>
  )
}

// 50x50 ê²©ìì„  ì»´í¬ë„ŒíŠ¸
function GridLines({ continentSize = 20 }: { continentSize?: number }) {
  const cellSize = continentSize / GRID_SIZE
  const halfSize = continentSize / 2
  
  return (
    <group position={[0, 0, 0.6]}> {/* ëŒ€ë¥™ë³´ë‹¤ ì•½ê°„ ìœ„ì— */}
      {/* ìˆ˜ì§ì„ ë“¤ (51ê°œ) */}
      {Array.from({ length: GRID_SIZE + 1 }, (_, i) => {
        const x = -halfSize + i * cellSize
        return (
          <mesh key={`vertical-${i}`} position={[x, 0, 0]}>
            <boxGeometry args={[0.05, continentSize, 0.01]} />
            <meshBasicMaterial color="#ffffff" opacity={0.3} transparent />
          </mesh>
        )
      })}
      
      {/* ìˆ˜í‰ì„ ë“¤ (51ê°œ) */}
      {Array.from({ length: GRID_SIZE + 1 }, (_, i) => {
        const y = -halfSize + i * cellSize
        return (
          <mesh key={`horizontal-${i}`} position={[0, y, 0]}>
            <boxGeometry args={[continentSize, 0.05, 0.01]} />
            <meshBasicMaterial color="#ffffff" opacity={0.3} transparent />
          </mesh>
        )
      })}
    </group>
  )
}

// íˆ¬ìì ì˜ì—­ ì‹œìŠ¤í…œ ë©”ì¸ ì»´í¬ë„ŒíŠ¸
function InvestorTerritories({ 
  investors, 
  continentSize = 20 
}: { 
  investors: Record<string, any>,
  continentSize?: number
}) {
  const investorsList = Object.values(investors)
  
  const placedSquares = investorsList.length > 0 ? spiralPlacement(investorsList) : []
  
  return (
    <group>
      {/* í•­ìƒ ê²©ìì„  í‘œì‹œ */}
      <GridLines continentSize={continentSize} />
      
      {/* íˆ¬ìì ì˜ì—­ë“¤ */}
      {placedSquares.map((square, index) => (
        <InvestorTerritory
          key={square.investor.id}
          investor={square.investor}
          gridX={square.gridX}
          gridY={square.gridY}
          gridSize={square.gridSize}
          continentSize={continentSize}
        />
      ))}
    </group>
  )
}

// íˆ¬ìì ì´ë¯¸ì§€ ì»´í¬ë„ŒíŠ¸ (ì›ë³¸ ë¹„ìœ¨ ìœ ì§€)
function InvestorImage({ 
  imageUrl, 
  cellSize,
  investorName,
  hovered,
  clicked,
  onPointerOver,
  onPointerOut,
  onClick
}: { 
  imageUrl?: string,
  cellSize: number,
  investorName: string,
  hovered?: boolean,
  clicked?: boolean,
  onPointerOver?: () => void,
  onPointerOut?: () => void,
  onClick?: () => void
}) {
  // í…ìŠ¤ì²˜ ë¡œë“œ (ì„ì‹œë¡œ test.jpg ì‚¬ìš©, ë‚˜ì¤‘ì— imageUrl ì‚¬ìš© ì˜ˆì •)
  const texture = useMemo(() => {
    const loader = new THREE.TextureLoader()
    // TODO: ë‚˜ì¤‘ì— ì‹¤ì œ ì‚¬ìš©ì ì´ë¯¸ì§€ë¡œ ë³€ê²½
    const imagePath = imageUrl || '/test.jpg'
    const tex = loader.load(
      imagePath,
      (texture) => {
        console.log(`âœ… ${investorName} ì´ë¯¸ì§€ ë¡œë“œ ì„±ê³µ:`, imagePath)
      },
      undefined,
      (error) => {
        console.error(`âŒ ${investorName} ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:`, error)
      }
    )
    tex.wrapS = THREE.ClampToEdgeWrapping
    tex.wrapT = THREE.ClampToEdgeWrapping
    return tex
  }, [imageUrl, investorName])

  // ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•œ ref
  const meshRef = useRef<THREE.Mesh>(null)

  // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ (meshì™€ ë™ì¼í•œ ë¡œì§)
  useFrame(() => {
    if (meshRef.current) {
      // í˜¸ë²„ íš¨ê³¼: í¬ê¸° ë³€í™” (1.05ë°°)
      const targetScale = hovered ? 1.05 : 1.0
      const currentScale = meshRef.current.scale.x
      const lerpScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1)
      meshRef.current.scale.setScalar(lerpScale)
      
      // í´ë¦­ íš¨ê³¼: ìœ„ì¹˜ ë³€í™” (0.2 ìœ„ë¡œ)
      const targetZ = clicked ? 0.4 : 0.2
      const currentZ = meshRef.current.position.z
      const lerpZ = THREE.MathUtils.lerp(currentZ, targetZ, 0.1)
      meshRef.current.position.z = lerpZ
    }
  })

  // ì´ë¯¸ì§€ í¬ê¸° = ì˜ì—­ í¬ê¸°ì™€ ì •í™•íˆ ë™ì¼
  const imageSize = useMemo(() => {
    // ì˜ì—­ í¬ê¸°ì™€ ì •í™•íˆ ê°™ì€ í¬ê¸°ë¡œ ì„¤ì • (Cover ë°©ì‹)
    return [cellSize, cellSize]
  }, [cellSize])

  return (
    <mesh 
      ref={meshRef}
      position={[0, 0, 0.2]}
      onPointerOver={onPointerOver}
      onPointerOut={onPointerOut}
      onClick={onClick}
    >
      <planeGeometry args={[imageSize[0], imageSize[1]]} />
      <meshBasicMaterial 
        map={texture}
        transparent={false}
        opacity={1.0}
      />
    </mesh>
  )
}



function SingleContinent({ continent }: { continent: Continent }) {
  const [x, y, z] = continent.position
  const { generateTestData } = useContinentStore()
  
  // ì‹¤ì œ íˆ¬ìì ë°ì´í„° - ìŠ¤í† ì–´ì—ì„œ ê°€ì ¸ì˜´
  const investors = continent.investors
  
  // í…ŒìŠ¤íŠ¸ìš©: ì¤‘ì•™ ëŒ€ë¥™ì— 50ëª… ë°°ì¹˜ (ê°ì 2% ì§€ë¶„, $200 íˆ¬ì)
  // í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ë„ë¡ useEffect ëŒ€ì‹  ì¡°ê±´ë¶€ ì‹¤í–‰
  if (continent.id === 'center' && Object.keys(investors).length === 0) {
    // ìŠ¤í† ì–´ì— í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
    generateTestData('center')
  }
  
  return (
    <group position={[x, y, z]}>
      {/* ëŒ€ë¥™ ë² ì´ìŠ¤ - ë‹¨ìˆœí•œ ì‚¬ê°í˜• (í¬ê¸° ì¦ê°€) */}
      <mesh position={[0, 0, 0]}>
        <boxGeometry args={[20, 20, 0.8]} />
        <meshStandardMaterial 
          color={continent.color} 
          opacity={1.0} 
          transparent={false} 
          roughness={0.6}
          metalness={0.2}
        />
      </mesh>
      
      {/* 50x50 ê²©ì ê¸°ë°˜ íˆ¬ìì ì˜ì—­ í‘œì‹œ (ê²©ìì„  í•­ìƒ í‘œì‹œ) */}
      <InvestorTerritories investors={investors} continentSize={20} />
    </group>
  )
}

function WorldScene() {
  const { continents } = useContinentStore()

  return (
    <group>
      {/* ì „ì—­ ì¡°ëª… */}
      <ambientLight intensity={0.5} />
      <pointLight position={[20, 20, 20]} intensity={1} />
      <pointLight position={[-20, -20, 20]} intensity={0.5} />
      
      {/* ëª¨ë“  ëŒ€ë¥™ ë Œë”ë§ */}
      {Object.values(continents).map((continent) => (
        <SingleContinent key={continent.id} continent={continent} />
      ))}
    </group>
  )
}

export default function ContinentMap() {
  const { selectedContinent, continents, isWorldView } = useContinentStore()
  
  // í˜„ì¬ ì„ íƒëœ ëŒ€ë¥™ ì •ë³´ (ìˆìœ¼ë©´ í•´ë‹¹ ëŒ€ë¥™, ì—†ìœ¼ë©´ ì¤‘ì•™ ëŒ€ë¥™)
  const displayContinent = selectedContinent ? continents[selectedContinent] : continents.center
  
  return (
    <main className="w-full h-screen" style={{ backgroundColor: '#37aff7' }}>
      {/* 3D Canvas */}
      <Canvas 
        camera={{ 
          position: [0, 0, 60], // 30 â†’ 60 (2ë°°) 
          fov: 75 
        }}
        className="w-full h-full"
        style={{ cursor: 'grab' }}
      >
        <CameraController />
        <WorldScene />
      </Canvas>
      
      {/* ìš°ìƒë‹¨ ì •ë³´ */}
      <div className="absolute top-20 right-4 text-white bg-black bg-opacity-80 p-4 rounded-lg">
        <h2 className="font-bold" style={{ color: displayContinent.color }}>
          {isWorldView ? 'ì„¸ê³„ ì§€ë„' : displayContinent.name}
        </h2>
        <div className="text-sm mt-2">
          {isWorldView ? (
            <>
              <p>ğŸŒ ì „ì²´ 5ê°œ ëŒ€ë¥™</p>
              <p>ğŸ“Š ì´ ì‚¬ìš©ì: {Object.values(continents).reduce((sum, c) => sum + c.currentUsers, 0)}ëª…</p>
            </>
          ) : (
            <>
              <p>ğŸ‘¥ ì‚¬ìš©ì: {displayContinent.currentUsers}/{displayContinent.maxUsers}</p>
              <p>ğŸ’° ì´ íˆ¬ìê¸ˆ: â‚©0</p>
            </>
          )}
          <p className="text-xs text-gray-400 mt-1">Stage 1-3: ì„¸ê³„ ì§€ë„ ì‹œìŠ¤í…œ</p>
        </div>
      </div>
    </main>
  )
} 